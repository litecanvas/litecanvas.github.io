// autocomplete suggestions
export default function customCompletions(context) {
  let word = context.matchBefore(/\w*/);
  if (word.from == word.to && !context.explicit) return null;
  return {
    from: word.from,
    options: [
      // global constants
      { label: "CANVAS", type: "constant", info: "game canvas HTML element" },
      { label: "WIDTH", type: "variable", info: "width of the game screen" },
      { label: "HEIGHT", type: "variable", info: "height of the game screen" },
      {
        label: "ELAPSED",
        type: "variable",
        info: "seconds since the game started",
      },
      { label: "FPS", type: "variable", info: "frames per second" },
      {
        label: "CENTERX",
        type: "variable",
        info: "middle X of the game screen",
      },
      {
        label: "CENTERY",
        type: "variable",
        info: "middle Y of the game screen",
      },
      { label: "PI", type: "constant" },
      { label: "TWO_PI", type: "constant" },
      { label: "HALF_PI", type: "constant" },
      // global functions
      {
        label: "cls",
        type: "function",
        apply: "cls(",
        detail: "(color?: number)",
        info: "clear the game screen",
      },
      {
        label: "rect",
        type: "function",
        apply: "rect(",
        detail: "(x, y, width, height, color=0, radii?)",
      },
      {
        label: "rectfill",
        type: "function",
        apply: "rectfill(",
        detail: "(x, y, width, height, color=0, radii?)",
      },
      {
        label: "circ",
        type: "function",
        apply: "circ(",
        detail: "(x, y, radius, color=0)",
      },
      {
        label: "circfill",
        type: "function",
        apply: "circfill(",
        detail: "(x, y, radius, color=0)",
      },
      {
        label: "line",
        type: "function",
        apply: "line(",
        detail: "(x1, y1, x2, y2, color=0)",
      },
      {
        label: "linewidth",
        type: "function",
        apply: "linewidth(",
        detail: "(value)",
      },
      {
        label: "linedash",
        type: "function",
        apply: "linedash(",
        detail: "(pattern, ofsset)",
      },
      {
        label: "text",
        type: "function",
        apply: "text(",
        detail: "(x, y, text, color=3)",
      },
      {
        label: "textfont",
        type: "function",
        apply: "textfont(",
        detail: "(fontName)",
        info: "default font: 'sans-serif'",
      },
      {
        label: "textsize",
        type: "function",
        apply: "textsize(",
        detail: "(size)",
        info: "default font size: 32",
      },
      {
        label: "textalign",
        type: "function",
        apply: "textalign(",
        detail: "(align, baseline)",
      },
      {
        label: "textstyle",
        type: "function",
        apply: "textstyle(",
        detail: "(style)",
      },
      {
        label: "textmetrics",
        type: "function",
        apply: "textmetrics(",
        detail: "(text, [size])",
      },
      {
        label: "image",
        type: "function",
        apply: "image(",
        detail: "(x, y, image)",
      },
      {
        label: "paint",
        type: "function",
        apply: "paint(",
        detail: "(width, height, callback|array, options)",
        info: "Creates a offscreen canvas to draw on it",
      },
      {
        label: "transform",
        type: "function",
        apply: "transform(",
        detail: "(a, b, c, d, e, f, reset=true)",
      },
      {
        label: "translate",
        type: "function",
        apply: "translate(",
        detail: "(x, y)",
      },
      {
        label: "scale",
        type: "function",
        apply: "scale(",
        detail: "(x, y)",
      },
      {
        label: "rotate",
        type: "function",
        apply: "rotate(",
        detail: "(radians)",
      },
      {
        label: "blendmode",
        type: "function",
        apply: "blendmode(",
        detail: "(mode)",
        info: "sets the type of compositing operation to apply when drawing new shapes",
      },
      {
        label: "alpha",
        type: "function",
        apply: "alpha(",
        detail: "(value)",
      },
      {
        label: "fill",
        type: "function",
        apply: "fill(",
        detail: "(color, path?)",
      },
      {
        label: "stroke",
        type: "function",
        apply: "stroke(",
        detail: "(color, path?)",
      },
      {
        label: "path",
        type: "function",
        apply: "path()",
        detail: "(arg?: string|Path2D)",
      },
      {
        label: "push",
        type: "function",
        apply: "push()",
        detail: "",
        info: "save the rendering context",
      },
      {
        label: "pop",
        type: "function",
        apply: "pop()",
        detail: "",
        info: "restore the rendering context",
      },
      {
        label: "ctx",
        type: "function",
        apply: "ctx()",
      },
      {
        label: "cliprect",
        type: "function",
        apply: "cliprect(",
        detail: "(x, y, width, height)",
        info: "create a rectagular clipping region",
      },
      {
        label: "clipcirc",
        type: "function",
        apply: "clipcirc(",
        detail: "(x, y, radius)",
        info: "create a circular clipping region",
      },
      {
        label: "sfx",
        type: "function",
        apply: "sfx(0)",
        detail: "(sound:number|Array, volume=1, pitch=0, randomness=0)",
        info: "play a sound",
      },
      {
        label: "rand",
        type: "function",
        apply: "rand()",
        detail: "(min=0.0, max=1.0)",
        info: "get a pseudo-random float between min (inclusive) and max (exclusive)",
      },
      {
        label: "randi",
        type: "function",
        apply: "randi()",
        detail: "(min=0, max=1)",
        info: "get a pseudo-random integer between min (inclusive) and max (inclusive)",
      },
      {
        label: "map",
        type: "function",
        apply: "map(",
        detail: "(val, min1, max1, min2, max2, withinBounds=false)",
      },
      {
        label: "norm",
        type: "function",
        apply: "norm(",
        detail: "(val, min, max)",
      },
      {
        label: "diff",
        type: "function",
        apply: "diff(",
        detail: "(a, b)",
      },
      {
        label: "clamp",
        type: "function",
        apply: "clamp(",
        detail: "(value, min, max)",
      },
      {
        label: "wrap",
        type: "function",
        apply: "wrap(",
        detail: "(value, min, max)",
      },
      {
        label: "lerp",
        type: "function",
        apply: "lerp(",
        detail: "(start, end, t)",
        info: "linear interpolation from `start` to `end` over `t`%.",
      },
      {
        label: "deg2rad",
        type: "function",
        apply: "deg2rad(",
        detail: "(degrees)",
      },
      {
        label: "rad2deg",
        type: "function",
        apply: "rad2deg(",
        detail: "(radians)",
      },
      {
        label: "sin",
        type: "function",
        apply: "sin(",
        detail: "(radians)",
      },
      {
        label: "cos",
        type: "function",
        apply: "cos(",
        detail: "(radians)",
      },
      {
        label: "tan",
        type: "function",
        apply: "tan(",
        detail: "(radians)",
      },
      {
        label: "abs",
        type: "function",
        apply: "abs(",
        detail: "(value)",
      },
      {
        label: "ceil",
        type: "function",
        apply: "ceil(",
        detail: "(value)",
      },
      {
        label: "round",
        type: "function",
        apply: "round(",
        detail: "(value)",
      },
      {
        label: "floor",
        type: "function",
        apply: "floor(",
        detail: "(value)",
      },
      {
        label: "trunc",
        type: "function",
        apply: "trunc(",
        detail: "(value)",
      },
      {
        label: "min",
        type: "function",
        apply: "min(",
        detail: "(...values)",
      },
      {
        label: "max",
        type: "function",
        apply: "max(",
        detail: "(...values)",
      },
      {
        label: "pow",
        type: "function",
        apply: "pow(",
        detail: "(a, b)",
      },
      {
        label: "sqrt",
        type: "function",
        apply: "sqrt(",
        detail: "(value)",
      },
      {
        label: "sign",
        type: "function",
        apply: "sign(",
        detail: "(value)",
      },
      {
        label: "atan2",
        type: "function",
        apply: "atan2(",
        detail: "(y, x)",
      },
      {
        label: "hypot",
        type: "function",
        apply: "hypot(",
        detail: "(...values)",
      },
      {
        label: "exp",
        type: "function",
        apply: "exp(",
        detail: "(x)",
      },
      {
        label: "colrect",
        type: "function",
        apply: "colrect(",
        detail: "(x1, y1, w1, h1, x2, y2, w2, h2)",
        info: "Check collision between 2 rectangles",
      },
      {
        label: "colcirc",
        type: "function",
        apply: "colcirc(",
        detail: "(x1, y1, r1, x2, y2, r2)",
        info: "Check collision between 2 circles",
      },
      {
        label: "mousepos",
        type: "function",
        apply: "mousepos()",
        detail: "() => [x, y]",
        info: "Gets the mouse X and Y",
      },
      {
        label: "use",
        type: "function",
        apply: "use(",
        detail: "(callback)",
        info: "Loads a plugin to extend the litecanvas engine",
      },
      {
        label: "setvar",
        type: "function",
        apply: "setvar(",
        detail: "(name, value)",
      },
      {
        label: "getcolor",
        type: "function",
        apply: "getcolor(",
        detail: "(index)",
      },
      {
        label: "listen",
        type: "function",
        apply: "listen(",
        detail: "(event, callback, [highPriority=false])",
      },
      {
        label: "emit",
        type: "function",
        apply: "emit(",
        detail: "(event,...data)",
      },
      {
        label: "resize",
        type: "function",
        apply: "resize(",
        detail: "(width, height)",
        info: "resizes the game canvas",
      },

      // asset loader plugin
      {
        label: "loadScript",
        type: "function",
        apply: "loadScript(",
        detail: "(url, callback)",
        info: "Load a JavaScript file",
      },
      {
        label: "loadImage",
        type: "function",
        apply: "loadImage(",
        detail: "(url, callback)",
        info: "Load a image",
      },
      {
        label: "loadFont",
        type: "function",
        apply: "loadFont(",
        detail: "(name, url, callback)",
        info: "Load a font",
      },
      {
        label: "LOADING",
        type: "variable",
        info: "return the amount of assets that are loading",
      },
    ],
  };
}
